$
Философия ошибок:
    1) При ошибке нужно привести программу в то состояние, в котором она была до ее возникновения
    2) При ошибке следует выводить информацию о ней, выполнять п1 и возваращать ее на более высокую абстракцию

Идеи реализации:
    1) Для обработки ошибок и освобождения памяти можно делать goto mark. mark: чистка памяти, печать инф-ии, возвращение ошибки
    2) Можно сделать тип возвращаемого значения каждой функции enum err_code.
       Принимаемые значения - const
       Возвращаемые значения - передаются по ссылке
    3)


$Подчистка информации при промежуточной ошибке в функции
1) Если функция алоцирует <= 1 пространст памяти, goto не применяю
2) Если п1) не выполняется, то вместо return делаю goto в конец файла, делаю
последовательные FREE (в обратном порядке), возращаю нейтральное значение

функиця отработала некоректно:
    *LastErr = ERR_CODE; // передаю ошибку вверх по абсракциям.
    DEBUG(ERR_CODE)
    goto END_POINT_<i>; // i - номер блока обработки ошибки, начиная с нуля

;// КОНЕЦ ФУНКЦИИ

END_POINT_<n>
FREE(ptr) ;// ptr - указатель, алоцированный перед блоком с ошибкой <n - 1>
END_POINT_<n - 1>
FREE(ptr)
END_POINT_<n - 2>
;// перед некоторыми поинтами не стоит FREE, т.к. перед данным блоком обработки ошибки не было алоцирования перменной
END_POINT_<n - 3>
...
END_POINT_<0>

return <значение, возвращаемое в случае ошибки(int : 0, void * : NULL, float : NaN и т.д.)>
mark пишу в формате END_POINT_<номер поинта начиная с нуля>

$Правила оформления define
1)названия функций #define FUNCTION
пишу с большой буквы, т.к.
все подставляемые препроцессором блоки должны называться с большой буквы (константы например)
2) после использования функции определенной в define не ставлю <;>
чтобы подчеркнуть, что это не определенная прототипом функция
